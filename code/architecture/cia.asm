// https://sta.c64.org/cbm64mem.html
// http://www.awsm.de/mem64/ 
// https://www.pagetable.com/c64ref/c64mem/

*=$dc00 "CIA #1 - inputs (keyboard, joystick, mouse), datasette, IRQ control" virtual
.namespace CIA1 {

    // $DC00
    // 56320	
    // Port A, keyboard matrix columns and joystick #2. Read bits:
    // Bit #0: 0 = Port 2 joystick up pressed.
    // Bit #1: 0 = Port 2 joystick down pressed.
    // Bit #2: 0 = Port 2 joystick left pressed.
    // Bit #3: 0 = Port 2 joystick right pressed.
    // Bit #4: 0 = Port 2 joystick fire pressed.
    // Write bits:
    // Bit #x: 0 = Select keyboard matrix column #x.
    // Bits #6-#7: Paddle selection; %01 = Paddle #1; %10 = Paddle #2.
    PortA:
        Address_Byte()

    // $DC01
    // 56321	
    // Port B, keyboard matrix rows and joystick #1. Bits:
    // Bit #x: 0 = A key is currently being pressed in keyboard matrix row #x, in the column selected at memory address $DC00.
    // Bit #0: 0 = Port 1 joystick up pressed.
    // Bit #1: 0 = Port 1 joystick down pressed.
    // Bit #2: 0 = Port 1 joystick left pressed.
    // Bit #3: 0 = Port 1 joystick right pressed.
    // Bit #4: 0 = Port 1 joystick fire pressed.
    PortB:
        Address_Byte()

    // $DC02
    // 56322	
    // Port A data direction register.
    // Bit #x: 0 = Bit #x in port A can only be read; 1 = Bit #x in port A can be read and written.
    PortADataDirection:
        Address_Byte()

    // $DC03
    // 56323	
    // Port B data direction register.
    // Bit #x: 0 = Bit #x in port B can only be read; 1 = Bit #x in port B can be read and written.
    PortBDataDirection:
        Address_Byte()

    // $DC04-$DC05
    // 56324-56325	
    // Timer A. Read: Current timer value.
    // Write: Set timer start value.
    TimerA:
        Address_Word()

    // $DC06-$DC07
    // 56326-56327	
    // Timer B. Read: Current timer value.
    // Write: Set timer start value.
    TimerB:
        Address_Word()

    // $DC08
    // 56328	
    // Time of Day, tenth seconds (in BCD). Values: $00-$09. Read: Current TOD value.
    // Write: Set TOD or alarm time.
    TimeOfDayDeciseconds:
        Address_Byte()

    // $DC09
    // 56329	
    // Time of Day, seconds (in BCD). Values: $00-$59. Read: Current TOD value.
    // Write: Set TOD or alarm time.
    TimeOfDaySeconds:
        Address_Byte()

    // $DC0A
    // 56330	
    // Time of Day, minutes (in BCD). Values: $00-$59. Read: Current TOD value.
    // Write: Set TOD or alarm time.
    TimeOfDayMinutes:
        Address_Byte()

    // $DC0B
    // 56331	
    // Time of Day, hours (in BCD). Read bits:
    // Bits #0-#5: Hours.
    // Bit #7: 0 = AM; 1 = PM.
    // Write: Set TOD or alarm time.
    TimeOfDayHours:
        Address_Byte()

    // $DC0C
    // 56332	
    // Serial shift register. (Bits are read and written upon every positive edge of the CNT pin.)
    SerialShift:
        Address_Byte()

    // $DC0D
    // 56333	
    // Interrupt control and status register. Read bits:
    // Bit #0: 1 = Timer A underflow occurred.
    // Bit #1: 1 = Timer B underflow occurred.
    // Bit #2: 1 = TOD is equal to alarm time.
    // Bit #3: 1 = A complete byte has been received into or sent from serial shift register.
    // Bit #4: Signal level on FLAG pin, datasette input.
    // Bit #7: An interrupt has been generated.
    // Write bits:
    // Bit #0: 1 = Enable interrupts generated by timer A underflow.
    // Bit #1: 1 = Enable interrupts generated by timer B underflow.
    // Bit #2: 1 = Enable TOD alarm interrupt.
    // Bit #3: 1 = Enable interrupts generated by a byte having been received/sent via serial shift register.
    // Bit #4: 1 = Enable interrupts generated by positive edge on FLAG pin.
    // Bit #7: Fill bit; bits #0-#6, that are set to 1, get their values from this bit; bits #0-#6, that are set to 0, are left unchanged.
    InterruptControlStatus:
        Address_Byte()

    // $DC0E
    // 56334	
    // Timer A control register. Bits:
    // Bit #0: 0 = Stop timer; 1 = Start timer.
    // Bit #1: 1 = Indicate timer underflow on port B bit #6.
    // Bit #2: 0 = Upon timer underflow, invert port B bit #6; 1 = upon timer underflow, generate a positive edge on port B bit #6 for 1 system cycle.
    // Bit #3: 0 = Timer restarts upon underflow; 1 = Timer stops upon underflow.
    // Bit #4: 1 = Load start value into timer.
    // Bit #5: 0 = Timer counts system cycles; 1 = Timer counts positive edges on CNT pin.
    // Bit #6: Serial shift register direction; 0 = Input, read; 1 = Output, write.
    // Bit #7: TOD speed; 0 = 60 Hz; 1 = 50 Hz.
    TimerAControl:
        Address_Byte()

    // $DC0F
    // 56335	
    // Timer B control register. Bits:
    // Bit #0: 0 = Stop timer; 1 = Start timer.
    // Bit #1: 1 = Indicate timer underflow on port B bit #7.
    // Bit #2: 0 = Upon timer underflow, invert port B bit #7; 1 = upon timer underflow, generate a positive edge on port B bit #7 for 1 system cycle.
    // Bit #3: 0 = Timer restarts upon underflow; 1 = Timer stops upon underflow.
    // Bit #4: 1 = Load start value into timer.
    // Bits #5-#6: %00 = Timer counts system cycles; %01 = Timer counts positive edges on CNT pin; %10 = Timer counts underflows of timer A; %11 = Timer counts underflows of timer A occurring along with a positive edge on CNT pin.
    // Bit #7: 0 = Writing into TOD registers sets TOD; 1 = Writing into TOD registers sets alarm time.
    TimerBControl:
        Address_Byte()

    // $DC10-$DCFF
    // 56336-56575	
    // CIA#1 register images (repeated every $10, 16 bytes).
    RegisterImages:
        Address_Bytes(240)      // $f0
}

*=$dd00 "CIA #2 - serial bus, RS232, NMI control" virtual
.namespace CIA2 {
    // $dd00
    // Port A, serial bus access. Bits:
    // Bits #0-#1: VIC bank. Values:
    // %00, 0: Bank #3, $C000-$FFFF, 49152-65535.
    // %01, 1: Bank #2, $8000-$BFFF, 32768-49151.
    // %10, 2: Bank #1, $4000-$7FFF, 16384-32767.
    // %11, 3: Bank #0, $0000-$3FFF, 0-16383.
    // Bit #2: RS232 TXD line, output bit.
    // Bit #3: Serial bus ATN OUT; 0 = High; 1 = Low.
    // Bit #4: Serial bus CLOCK OUT; 0 = High; 1 = Low.
    // Bit #5: Serial bus DATA OUT; 0 = High; 1 = Low.
    // Bit #6: Serial bus CLOCK IN; 0 = Low; 1 = High.
    // Bit #7: Serial bus DATA IN; 0 = Low; 1 = High.
    PortASerialBusAccess:
        Address_Byte()

    // $DD01
    // 56577
    // Port B, RS232 access. Read bits:
    // Bit #0: RS232 RXD line, input bit.
    // Bit #3: RS232 RI line.
    // Bit #4: RS232 DCD line.
    // Bit #5: User port H pin.
    // Bit #6: RS232 CTS line; 1 = Sender is ready to send.
    // Bit #7: RS232 DSR line; 1 = Receiver is ready to receive.
    // Write bits:
    // Bit #1: RS232 RTS line. 1 = Sender is ready to send.
    // Bit #2: RS232 DTR line. 1 = Receiver is ready to receive.
    // Bit #3: RS232 RI line.
    // Bit #4: RS232 DCD line.
    // Bit #5: User port H pin.
    PortBRS232Access:
        Address_Byte()

    // $DD02
    // 56578
    // Port A data direction register.
    // Bit #x: 0 = Bit #x in port A can only be read; 1 = Bit #x in port A can be read and written.
    PortADataDirection:
        Address_Byte()

    // $DD03
    // 56579
    // Port B data direction register.
    // Bit #x: 0 = Bit #x in port B can only be read; 1 = Bit #x in port B can be read and written.
    PortBDataDirection:
        Address_Byte()

    // $DD04-$DD05
    // 56580-56581
    // Timer A. Read: Current timer value.
    // Write: Set timer start value.
    TimerA:
        Address_Word()

    // $DD06-$DD07
    // 56582-56583
    // Timer B. Read: Current timer value.
    // Write: Set timer start value.
    TimerB:
        Address_Word()

    // $DD08
    // 56584
    // Time of Day, tenth seconds (in BCD). Values: $00-$09. Read: Current TOD value.
    // Write: Set TOD or alarm time.
    TimeOfDayDeciseconds:
        Address_Byte()

    // $DD09
    // 56585
    // Time of Day, seconds (in BCD). Values: $00-$59. Read: Current TOD value.
    // Write: Set TOD or alarm time.
    TimeOfDaySeconds:
        Address_Byte()

    // $DD0A
    // 56586
    // Time of Day, minutes (in BCD). Values: $00-$59. Read: Current TOD value.
    // Write: Set TOD or alarm time.
    TimeOfDayMinutes:
        Address_Byte()

    // $DD0B
    // 56587
    // Time of Day, hours (in BCD). Read bits:
    // Bits #0-#5: Hours.
    // Bit #7: 0 = AM; 1 = PM.
    // Write: Set TOD or alarm time.
    TimeOfDayHours:
        Address_Byte()

    // $DD0C
    // 56588
    // Serial shift register. (Bits are read and written upon every positive edge of the CNT pin.)
    SerialShift:
        Address_Byte()

    // $DD0D
    // 56589
    // Interrupt control and status register. Read bits:
    // Bit #0: 1 = Timer A underflow occurred.
    // Bit #1: 1 = Timer B underflow occurred.
    // Bit #2: 1 = TOD is equal to alarm time.
    // Bit #3: 1 = A complete byte has been received into or sent from serial shift register.
    // Bit #4: Signal level on FLAG pin.
    // Bit #7: A non-maskable interrupt has been generated.
    // Write bits:
    // Bit #0: 1 = Enable non-maskable interrupts generated by timer A underflow.
    // Bit #1: 1 = Enable non-maskable interrupts generated by timer B underflow.
    // Bit #2: 1 = Enable TOD alarm non-maskable interrupt.
    // Bit #3: 1 = Enable non-maskable interrupts generated by a byte having been received/sent via serial shift register.
    // Bit #4: 1 = Enable non-maskable interrupts generated by positive edge on FLAG pin.
    // Bit #7: Fill bit; bits #0-#6, that are set to 1, get their values from this bit; bits #0-#6, that are set to 0, are left unchanged.
    InterruptControlStatus:
        Address_Byte()

    // $DD0E
    // 56590
    // Timer A control register. Bits:
    // Bit #0: 0 = Stop timer; 1 = Start timer.
    // Bit #1: 1 = Indicate timer underflow on port B bit #6.
    // Bit #2: 0 = Upon timer underflow, invert port B bit #6; 1 = upon timer underflow, generate a positive edge on port B bit #6 for 1 system cycle.
    // Bit #3: 0 = Timer restarts upon underflow; 1 = Timer stops upon underflow.
    // Bit #4: 1 = Load start value into timer.
    // Bit #5: 0 = Timer counts system cycles; 1 = Timer counts positive edges on CNT pin.
    // Bit #6: Serial shift register direction; 0 = Input, read; 1 = Output, write.
    // Bit #7: TOD speed; 0 = 60 Hz; 1 = 50 Hz.
    TimerAControl:
        Address_Byte()

    // $DD0F
    // 56591
    // Timer B control register. Bits:
    // Bit #0: 0 = Stop timer; 1 = Start timer.
    // Bit #1: 1 = Indicate timer underflow on port B bit #7.
    // Bit #2: 0 = Upon timer underflow, invert port B bit #7; 1 = upon timer underflow, generate a positive edge on port B bit #7 for 1 system cycle.
    // Bit #3: 0 = Timer restarts upon underflow; 1 = Timer stops upon underflow.
    // Bit #4: 1 = Load start value into timer.
    // Bits #5-#6: %00 = Timer counts system cycles; %01 = Timer counts positive edges on CNT pin; %10 = Timer counts underflows of timer A; %11 = Timer counts underflows of timer A occurring along with a positive edge on CNT pin.
    // Bit #7: 0 = Writing into TOD registers sets TOD; 1 = Writing into TOD registers sets alarm time.
    TimerBControl:
        Address_Byte()

    // $DD10-$DDFF
    // 56592-56831
    // CIA#2 register images (repeated every $10, 16 bytes).
    CIA2RegisterImages:
        Address_Bytes(240)         // $f0
}